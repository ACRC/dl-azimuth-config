# Terraform state

`azimuth-ops` uses [Terraform](https://www.terraform.io/) to manage the K3S node in both the
single node and high-availability deployment deployment methods.

In order to keep track of the resources that it has created, and how they map to the resources
in the Terraform configuration generated by `azimuth-ops`, Terraform must
[store its state](https://www.terraform.io/language/state) somewhere. The location of the
state is determined by the
[backend configuration](https://www.terraform.io/language/settings/backends/configuration).

Each environment in an `azimuth-config` repository has a corresponding Terraform state, and
they are independent from each other.

## Local state

By default `azimuth-ops` will use the `local` backend, which stores the Terraform state as
a file on the local disk in the `.work` directory. This requires no explicit configuration,
but comes with the usual caveats about keeping important state on your local machine.

!!! danger  "Not suitable for production"

    Local state is sufficient for a demonstration or evaluation, but for a shared or
    production deployment it is recommended to use remote state.

## Remote state

Terraform supports a number of remote backends that can be used to persist Terraform state
independently of where a deployment is run. This allows deployments to be made from anywhere
that can access the state without corrupting or conflicting with any existing resources
from previous deployments.

!!! warning

    In order to avoid multiple writers when using remote state, it is recommended to use
    a backend that supports
    [state locking](https://www.terraform.io/language/state/locking).

!!! tip

    Configuration of the Terraform backend is done using Linux environment variables, using
    [env files in azimuth-config environments](../environments.md#linux-environment-variables).

The `azimuth-ops` and `azimuth-config` tooling currently only support a subset of the
available Terraform backends. The following backends are currently supported:

### HTTP

The [HTTP backend](https://www.terraform.io/language/settings/backends/http) is a simple
REST client that uses `GET`, `POST` and `DELETE` HTTP requests to manage a Terraform
state. State locking is optional, but it is recommended to use an implementation that
supports it.

To use the HTTP backend, you must set *at least* the following environment variables:

```sh  title="env"
# Tell azimuth-ops to use the HTTP backend
AZIMUTH_TERRAFORM_BACKEND_TYPE=http

# The state endpoint for the environment
# Using the AZIMUTH_ENVIRONMENT variable means this is different for each environment
# without needing environment-specific variables
TF_HTTP_ADDRESS="https://example.org/tfstate/${AZIMUTH_ENVIRONMENT}"
```

For the full set of available environment variables, see the Terraform docs.

#### GitLab

!!! tip

    This is the recommended option if you are using [GitLab](https://about.gitlab.com/)
    for your config repository.

If you are using GitLab to host your configuration repository, either `gitlab.com` or
self-hosted, you can use
[GitLab-managed Terraform state](https://docs.gitlab.com/ee/user/infrastructure/iac/terraform_state.html)
to store the Terraform state for your environments.

GitLab provides a HTTP backend that can be configured by putting the following into your
the `env` file for your repository:

```sh  title="env"
# Use the http backend type
AZIMUTH_TERRAFORM_BACKEND_TYPE=http

# The API base URL for the target GitLab project
#   For a self-hosted GitLab instance, replace gitlab.com with your domain
GITLAB_PROJECT_URL="https://gitlab.com/api/v4/projects/<project id>"

# The state endpoint for the environment
TF_HTTP_ADDRESS="${GITLAB_PROJECT_URL}/terraform/state/${AZIMUTH_ENVIRONMENT}"

# The state-locking endpoint for the environment
TF_HTTP_LOCK_ADDRESS="${GITLAB_PROJECT_URL}/terraform/state/${AZIMUTH_ENVIRONMENT}/lock"
TF_HTTP_LOCK_METHOD="POST"

# The state-unlocking endpoint for the environment
TF_HTTP_UNLOCK_ADDRESS="${GITLAB_PROJECT_URL}/terraform/state/${AZIMUTH_ENVIRONMENT}/lock"
TF_HTTP_UNLOCK_METHOD="DELETE"
```

The username and password (or token) that are used to authenticate with GitLab to manage
the Terraform state are set using the `TF_HTTP_USERNAME` and `TF_HTTP_PASSWORD` environment
variables respectively.

If you are [using GitLab CI/CD to automate deployments](../deployment/automation.md#gitlab-cicd),
then the pipeline will be issued with a suitable token. The
[sample configuration](https://github.com/stackhpc/azimuth-config/blob/main/.gitlab-ci.yml.sample)
includes configuration to populate these variables using this token.

If you are not using automation but your GitLab installation has
[project access tokens](https://docs.gitlab.com/ee/user/project/settings/project_access_tokens.html)
available, you can configure a project access token and store it (encrypted!) in the
`env.secret` file, referencing the bot username:

```sh  title="env.secret"
TF_HTTP_USERNAME="project_<id>_bot"
TF_HTTP_PASSWORD="<project access token>"
```

If you need to access an environment deployed using automation, or you do not have project
access tokens available, then you can use a
[Personal access token](https://docs.gitlab.com/ee/user/profile/personal_access_tokens.html),
which at least avoids using your password.

!!! danger  "Committing personal access tokens"

    You should **never** commit a personal access token to the configuration repository,
    even encrypted, because it is not possible to set a project scope.

If using a personal access token, you should export the relevant variables before activating
an environment:

```sh
# Export directly
export TF_HTTP_USERNAME="<username>"
export TF_HTTP_PASSWORD="<token>"

# Export from a file that has been added to .gitignore
export $(cat env.gitlab-creds | xargs)

source ./bin/activate my-site
```

### S3

DOCUMENTATION COMING SOON!
