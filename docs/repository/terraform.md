# Terraform state

`azimuth-ops` uses [Terraform](https://www.terraform.io/) to manage the K3S node in both the
single node and high-availability deployment deployment methods.

In order to keep track of the resources that it has created, and how they map to the resources
in the Terraform configuration generated by `azimuth-ops`, Terraform must
[store its state](https://www.terraform.io/language/state) somewhere. The location of the
state is determined by the
[backend configuration](https://www.terraform.io/language/settings/backends/configuration).

Each environment in an `azimuth-config` repository has a corresponding Terraform state, and
they are independent from each other.

## Local state

By default `azimuth-ops` will use the `local` backend, which stores the Terraform state as
a file on the local disk in the `.work` directory. This requires no explicit configuration,
but comes with the usual caveats about keeping important state on your local machine.

!!! warning

    Local state is sufficient for a demonstration or evaluation, but for a shared or
    production deployment it is recommended to use remote state.

## Remote state

Terraform supports a number of remote backends that can be used to persist Terraform state
independently of where a deployment is run. This allows deployments to be made from anywhere
that can access the state without corrupting or conflicting with any existing resources
from previous deployments.

!!! warning

    In order to avoid multiple writers when using remote state, it is recommended to use
    a backend that supports
    [state locking](https://www.terraform.io/language/state/locking).

!!! tip

    Configuration of the Terraform backend is done using Linux environment variables, using
    [env files in azimuth-config environments](../environments.md#linux-environment-variables).

The `azimuth-ops` and `azimuth-config` tooling currently only support a subset of the
available Terraform backends. The following backends are currently supported:

### HTTP

The [HTTP backend](https://www.terraform.io/language/settings/backends/http) is a simple
REST client that uses `GET`, `POST` and `DELETE` HTTP requests to manage a Terraform
state. State locking is optional, but it is recommended to use an implementation that
supports it.

To use the HTTP backend, you must set *at least* the following environment variables:

```sh  title="env"
# Tell azimuth-ops to use the HTTP backend
AZIMUTH_TERRAFORM_BACKEND_TYPE=http

# The state endpoint for the environment
# Using the AZIMUTH_CONFIG_ENVIRONMENT variables means this is different
# for each environment without needing environment-specific variables
TF_HTTP_ADDRESS="https://example.org/tfstate/${AZIMUTH_CONFIG_ENVIRONMENT}"
```

For the full set of available environment variables, see the Terraform docs.

#### GitLab

!!! tip

    This is the recommended option if you are using [GitLab](https://about.gitlab.com/)
    for your config repository.

If you are using GitLab to host your configuration repository, either `gitlab.com` or
self-hosted, you can use
[GitLab-managed Terraform state](https://docs.gitlab.com/ee/user/infrastructure/iac/terraform_state.html)
to store the Terraform state for your environments.

GitLab provides a HTTP backend that can be configured by putting the following into your
the `env` file for your repository:

```sh  title="env"
# Use the http backend type
AZIMUTH_TERRAFORM_BACKEND_TYPE=http

# The API base URL for the target GitLab project
#   For a self-hosted GitLab instance, replace gitlab.com with your domain
GITLAB_PROJECT_URL="https://gitlab.com/api/v4/projects/<project id>"

# The state endpoint for the environment
TF_HTTP_ADDRESS="${GITLAB_PROJECT_URL}/terraform/state/${AZIMUTH_CONFIG_ENVIRONMENT}"

# The state-locking endpoint for the environment
TF_HTTP_LOCK_ADDRESS="${GITLAB_PROJECT_URL}/terraform/state/${AZIMUTH_CONFIG_ENVIRONMENT}/lock"
TF_HTTP_LOCK_METHOD="POST"

# The state-unlocking endpoint for the environment
TF_HTTP_UNLOCK_ADDRESS="${GITLAB_PROJECT_URL}/terraform/state/${AZIMUTH_CONFIG_ENVIRONMENT}/lock"
TF_HTTP_UNLOCK_METHOD="DELETE"
```

If your GitLab installation has
[bot users for projects](https://docs.gitlab.com/ee/user/project/settings/project_access_tokens.html#bot-users-for-projects)
available, you can configure a project access token and store it (encrypted!) in the
`env.secret` file:

```sh  title="env.secret"
TF_HTTP_USERNAME="project_<id>_bot"
TF_HTTP_PASSWORD="<project access token>"
```

If you are using personal GitLab credentials, then they should not be committed to the
repository, even encrypted, because it is not possible to set the project scope.
Instead, you can export them before activating your environment:

```sh
export TF_HTTP_USERNAME="<username>"
export TF_HTTP_PASSWORD="<token>"

source ./bin/activate my-site
```

### S3

DOCUMENTATION COMING SOON!
